#=Задача 1. Написать функцию, получающую на вход вектор кортежей с координатами точек плоскости, 
и возвращающую вектор кортежей с координатами точек плоскости, являющимися вершинами выпуклой оболочки заданных точек. 
Реализовать метод Джарвиса. Выполнить графическое тестирование работы этой функции, т.е. для произвольно заданных исходных данных 
отображать на графике исходные точки и полученную выпуклую оболочку.=#
#k - количество точек в оболочке, n - количество заданных точек
function jarvismarch(A) 
    n = length(A)
    P = collect(n) 
    for i in 2:n # берем самую левую точку из A
        if A[P[i]][1]<A[P[1]][1] 
            P[i], P[1] = P[1], P[i]  
    end

    H = [P[1]] # делаем стартовую вершину текущей, ищем самую правую точку в A относительно текущей вершины, делаем ее текущей и т.д.
    delete!(P,P[1])
    P.insert!(H[1])

    while True # Теперь организуем бесконечный цикл, на каждой итерации которого ищем самую левую точку из P относительно последней вершины в H
        right = 0
        for i in 2:len(P)
          if rotate(A[H[-1]],A[P[right]],A[P[i]])<0
            right = i
          end
        end
        if P[right]==H[1]
          break
        else
          H.insert!(P[right])
          delete!(P,P[right])
        end
      return H
    end
end
#=Задача 2. Написать функцию, получающую на вход вектор кортежей с координатами точек плоскости, 
и возвращающую вектор кортежей с координатами точек плоскости, являющимися вершинами выпуклой оболочки заданных точек. 
Реализовать метод Грехема. Выполнить графическое тестирование работы этой функции, т.е. для произвольно заданных исходных данных 
отображать на графике исходные точки и полученную выпуклую оболочку.=#
function grehem(A)
    n = length(A) 
    P = collect(n) 
    for i in 2:n 
        if A[P[i]][1]<A[P[1]][1] 
        P[i], P[1] = P[1], P[i] 
    for i in 3:n # сортировка вставкой
        j = i
        while ((j>1) && (rotate(A[P[0]],A[P[j-1]],A[P[j]])<0))
            P[j], P[j-1] = P[j-1], P[j]
            j -= 1
        end
    end
    S = collect(2)
    S[1] = P[1]
    S[2] = P[2]    
    for i in 3:n
        while (rotate(A[S[-2]],A[S[-1]],A[P[i]])<0)
            delete!(S,S[-1]) 
        end
        S.insert!(P[i]) 
    end
    return S
end
